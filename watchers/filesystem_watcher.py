#!/usr/bin/env python3
"""
File System Watcher - Bronze Tier Perception Layer

Monitors a designated folder for new files and creates structured task files
in the AI Employee Vault Inbox folder.

Requirements:
- watchdog: pip install watchdog
- python-dotenv: pip install python-dotenv
"""

import os
import sys
import time
import shutil
from pathlib import Path
from datetime import datetime, timezone
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configuration
WATCH_DIRECTORY = os.getenv('WATCH_DIRECTORY', os.path.expanduser('~/Downloads'))
VAULT_INBOX = os.getenv('VAULT_INBOX', 'AI_Employee_Vault/Inbox')
FILE_EXTENSIONS = os.getenv('WATCHER_EXTENSIONS', '.pdf,.doc,.docx,.txt,.md,.jpg,.png').split(',')

class TaskCreator:
    """Handles creation of structured task files in the Inbox."""

    def __init__(self, inbox_path: str):
        self.inbox_path = Path(inbox_path)
        self.inbox_path.mkdir(parents=True, exist_ok=True)

    def create_task(self, file_path: str, event_type: str = 'created') -> str:
        """
        Create a structured task file in the Inbox.

        Args:
            file_path: Path to the file that triggered the event
            event_type: Type of file system event (created, modified, moved)

        Returns:
            Path to the created task file
        """
        file_path = Path(file_path)
        timestamp = datetime.now(timezone.utc).isoformat()

        # Generate task filename
        task_id = timestamp.replace(':', '-').replace('.', '-')[:19]
        task_filename = f"task-{task_id}.md"
        task_path = self.inbox_path / task_filename

        # Get file metadata
        file_size = file_path.stat().st_size if file_path.exists() else 0
        file_ext = file_path.suffix

        # Create task content
        task_content = f"""# New File Detected

**Created**: {timestamp}
**Status**: pending
**Type**: watcher-event
**Source**: FileSystemWatcher
**Priority**: medium

## File Information

- **Path**: `{file_path}`
- **Size**: {file_size:,} bytes
- **Extension**: {file_ext or 'none'}
- **Event Type**: {event_type}

## Description

A new file has been detected in the watched directory. This task requires review and processing.

## Suggested Actions

1. **Review**: Examine the file to understand its content and purpose
2. **Categorize**: Determine what type of task this represents (document, image, etc.)
3. **Process**: Take appropriate action based on file type and content
4. **Archive**: Move to Done when processing is complete

## Context

This task was automatically generated by the FileSystemWatcher. The watcher monitors the directory for new files and creates tasks to ensure nothing is missed.

## Processing

### AI Analysis
*To be filled by Claude when processing this task*

### Actions Taken
*To be filled by Claude when processing this task*

### Result
*To be filled by Claude when processing this task*

**Completed**: *To be filled*
"""

        # Write task file
        with open(task_path, 'w', encoding='utf-8') as f:
            f.write(task_content)

        print(f"[✓] Task created: {task_filename}")
        return str(task_path)


class FileSystemWatcher(FileSystemEventHandler):
    """Watches a directory for file system events."""

    def __init__(self, task_creator: TaskCreator):
        self.task_creator = task_creator
        self.cooldown = {}  # Prevent duplicate tasks for same file
        self.cooldown_period = 5  # seconds

    def should_create_task(self, file_path: str) -> bool:
        """Check if we should create a task for this file (avoid duplicates)."""
        now = time.time()

        # Check if recently processed
        if file_path in self.cooldown:
            if now - self.cooldown[file_path] < self.cooldown_period:
                return False

        # Check file extension
        file_ext = Path(file_path).suffix.lower()
        if FILE_EXTENSIONS and file_ext not in FILE_EXTENSIONS:
            return False

        # Skip hidden files and task files
        if Path(file_path).name.startswith('.'):
            return False

        return True

    def on_created(self, event):
        """Handle file/directory creation events."""
        if event.is_directory:
            return

        if self.should_create_task(event.src_path):
            self.task_creator.create_task(event.src_path, 'created')
            self.cooldown[event.src_path] = time.time()

    def on_moved(self, event):
        """Handle file/directory move events."""
        if event.is_directory:
            return

        if self.should_create_task(event.dest_path):
            self.task_creator.create_task(event.dest_path, 'moved')
            self.cooldown[event.dest_path] = time.time()


def main():
    """Main entry point for the FileSystemWatcher."""
    print("=" * 60)
    print("File System Watcher - Bronze Tier Perception Layer")
    print("=" * 60)
    print()

    # Ensure paths exist
    watch_dir = Path(WATCH_DIRECTORY).expanduser().resolve()
    inbox_dir = Path(VAULT_INBOX).resolve()

    if not watch_dir.exists():
        print(f"[ERROR] Watch directory does not exist: {watch_dir}")
        print(f"Please create it or update WATCH_DIRECTORY in .env")
        sys.exit(1)

    print(f"[CONFIG] Watching: {watch_dir}")
    print(f"[CONFIG] Inbox: {inbox_dir}")
    print(f"[CONFIG] Extensions: {FILE_EXTENSIONS}")
    print()

    # Create task creator
    task_creator = TaskCreator(str(inbox_dir))

    # Setup watcher
    event_handler = FileSystemWatcher(task_creator)
    observer = Observer()
    observer.schedule(event_handler, str(watch_dir), recursive=False)

    # Start watching
    observer.start()
    print("[START] Watcher is now running...")
    print("[INFO] Press Ctrl+C to stop")
    print()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        print()
        print("[STOP] Shutting down watcher...")
        observer.stop()
    observer.join()

    print("[✓] Watcher stopped cleanly")


if __name__ == '__main__':
    main()
